<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>
    // 链式调用
    var p = new Promise(function (resolve, reject) {
      // 异步操作
      if (1) {
        resolve("Success")
      } else {
        reject("failure")
      }
    });
    p.then(function (data) {//处理异步操作成功数据
      return new Promise((resolve) => {
        resolve(data + "xxx1")
      })
    }).then(function (data) {///处理异步操作成功数据
      //处理异步操作的结果
      //上⾯的那⼀段then函数的简化写法
      return Promise.resolve(data + "xxx2")
    }).then((data) => {//处理异步成功操作数据。简化为箭头函数
      //处理异步操作的结果
      //上⾯的那⼀段then函数更简化的写法
      return data + "xxx3"
    }).catch(function (error) {
      console.log("错误提示");
    })
    /* 
    
    上⾯关于Promise对象的构建，并调⽤resolve⽅法，写了三种形式。这三种形式效果是⼀样
    的。后两种⽅式进⾏了不同程度的简写。简单起⻅，成功回调函数的参数data就写成了字符
    串，字符串也是⼀种对象。同样，下⾯三种构造Promise对象，并调⽤reject⽅法的三种形式，也是⼀样的效果。
    
    */
    /*  ⽅式⼀：
 return new Promise((resolve.reject)=>{
 reject({errorMsg:""})
 })
 ⽅式⼆：
 return Promise.reject({errorMsg:""})
 ⽅式三：
 throw {errorMsg:""}
  */

  </script>
</body>
</html>